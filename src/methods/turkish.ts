import { VerbProperties } from '../interfaces';
import { map } from './utils';
import { isNegativeVerb } from './verbVerification';
import { harmony, mutableVerbs, compositionExceptions } from '../rules';
import {
  compose,
  length,
  reverseStr,
  getVowelsStr,
  getStrLast,
  getStrInit,
} from './basics';

/**
 * @description This function is used to extract the content before the verb root from a given verb. Ex: ETMEK -> ET
 * @param {string} str
 * @returns {string}
 */
const verbRoot = (str: string): string => str.slice(0, -3);

/**
 * @description This function is used to extract the content before the negative verb root from a given verb. Ex: ETMEMEK -> ET
 * @param {string} str
 * @returns {string}
 */
const getPositiveVerbRootFromNegativeVerb = (str: string): string =>
  str.slice(0, -5);

/**
 * @description This object contains some functions that generates Arrays with personal suffixes that will
 * be added to the conjugations
 * I = first type: im, sin, (i), iz, siniz (lar or ler is added later)
 * II = second type: im, in, (i), ik, siniz (lar or ler is added later)
 * IN = first type negative: m, zsin, z, yiz, zsiniz (lar or ler is added later. The -z is not added in first person singular and first person plurar)
 */
const arrayOfPersonalSuffixes = {
  I: (i: string, z: string = '') => [
    `${i}m`,
    `${z}s${i}n`,
    `${z}`,
    `${i}z`,
    `${z}s${i}n${i}z`,
  ],
  II: (i: string, e: string = i) => [
    `${i}m`,
    `${i}n`,
    `${i}`,
    `${i}k`,
    `${i}n${e}z`,
  ],
  IN: (i: string) => [`m`, `zs${i}n`, `z`, `y${i}z`, `zs${i}n${i}z`],
};

/**
 * @description This function is going to take a Verb, get its root, and count the vowels in that root
 * @param {string} - a verb where to look for vowels
 * @returns {number} - the quantity of vowels in the verb's root
 */
const vowelsQuantity = compose<number>(
  verbRoot,
  getVowelsStr,
  length
);

/**
 * @description Does this verb have only one syllable?
 * @param {string} verb
 * @returns {boolean} - is it one syllable or not?
 */
const isSingleSyllableVerb = (verb: string): boolean =>
  vowelsQuantity(verb) === 1;

/**
 * Returns the first vowel in a string
 * @param {string}
 * @returns {string}
 */
const getFirstVowel = (str: string): string =>
  (str.match(/[aeiıouöü]/i) || [''])[0];

/**
 * Returns the last vowel in a string
 * @param {string}
 * @returns {string}
 */
const getLastVowel = compose<string>(
  reverseStr,
  getFirstVowel
);

const lookFor = {
  '4 way harmony': (vowel: string): string =>
    harmony.fourWays
      .find((stringOfVowels) => {
        /**
         * harmony.fourWays is an array with 'string of vowels' that looks like: ['aı', 'ou', 'ei', 'öü']
         * we'll see if one of these string of vowels contains the given @param VOWEL
         * stringOfVowels.includes(vowel) will give us one of these strings
         * and with slice(-1) we'll get its harmony, because this strings are made for
         * having the harmony letter in the final of the string
         * so the 'string of vowel': 'aı' returns -> 'ı'
         * THIS PRINCIPLE WILL ALSO BE USED WITH THE '2 way harmony' @function in this object.
         */
        return stringOfVowels.includes(vowel);
      })
      .slice(-1),
  '2 way harmony': (vowel: string): string =>
    harmony.twoWays
      .find((stringOfVowels) => stringOfVowels.includes(vowel))
      .slice(-1),
};

const lookIn4Ways = lookFor['4 way harmony'];
const lookIn2Ways = lookFor['2 way harmony'];

/**
 * @description This function figure out a verb's 4-Way-Harmony
 * @param {string} - A verb in its infinitive form (so with -mek, -mak. Ex: Etmek, Bilmek)
 * @returns {string} - a 1 length string that could be one of these: [ı, u, i, ü] representing the 4-way-harmony
 */
const get4WayHarmonyOf = compose<string>(
  verbRoot,
  getLastVowel,
  lookIn4Ways
);

/**
 * @description This function figure out a verb's 2-Way-Harmony
 * @param {string} - A verb in its infinitive form (so with -mek, -mak. Ex: Etmek, Bilmek)
 * @returns {string} - a 1 length string that could be one of these: [a, e] representing the 2-way-harmony
 */
const get2WayHarmonyOf = compose<string>(
  verbRoot,
  getLastVowel,
  lookIn2Ways
);

/**
 * @description This func puts every part of the conjugation together an generates a final array.
 * @param {Object} props
 * @prop props.personalSuffixes - an array of personal suffixes generated by one of the @func in the arrayOfPersonalSuffixes Object
 * @prop props.firstPart - when a verb is composed, we need to extract the firstPart of it, @example:The firstPart of 'Yardım etmek' is: 'Yardım'
 * @prop props.verbRoot - the root of a verb (a verb without -mek or -mak, @example: Bilmek -> Bil)
 * @prop props.tenseSuffix - the verb tense suffix, example: aorist, gerund, future, past, potential... This param could be empty because sometimes props.verbRoot already has the tenseSuffix on it (in negative forms of a verb for example)
 */
const generateResult = ({
  personalSuffixes,
  firstPart,
  verbRoot,
  tenseSuffix = '',
}): string[] => {
  return map(
    personalSuffixes,
    (suffix) => firstPart + verbRoot + tenseSuffix + suffix
  );
  /**
   * @example with verb 'bilmek'
   * personalSuffixes will looks like: [ 'im', 'sin', '', 'iz', 'siniz', 'ler' ]
   * 	We'll map over each element and generate conjugations
   * verbRoot: bil
   * tenseSuffix: ir (when it's Aorist tense)
   * RESULT -> [ 'bilirim','bilirsin','bilir','biliriz','bilirsiniz','bilirler' ]
   */
};

/**
 * Verify if a string has more than 0 white spaces on it
 * @param {string} str
 * @returns {boolean}
 */
const hasWhiteSpaces = (str: string): boolean => str.split(' ').length > 1;

var regGet: RegExp = /(geçmek|etmek|yapmak|eylemek|olmak|vermek|kalmak|edilmek|demek|dilemek|gelmek|bulunmak|söylemek|durmak)$/;
var regIs: RegExp = /^[a-zşüıöğç\s?]{2,}(geçmek|etmek|yapmak|eylemek|olmak|vermek|kalmak|edilmek|demek|dilemek|gelmek|bulunmak|söylemek|durmak)$/;

var regGetNeg: RegExp = /(geçmemek|etmemek|yapmamak|eylememek|olmamak|vermemek|kalmamak|edilmemek|dememek|dilememek|gelmemek|bulunmamak|söylememek|durmamak)$/;
var regIsNeg: RegExp = /^[a-zşüıöğç\s?]{2,}(geçmemek|etmemek|yapmamak|eylememek|olmamak|vermemek|kalmamak|edilmemek|dememek|dilememek|gelmemek|bulunmamak|söylememek|durmamak)$/;

const isAuxiliaryComposedVerb = (verb: string): boolean => {
  return regIs.test(verb) && !compositionExceptions.includes(verb);
};

const isAuxiliaryComposedVerbInNegativeForm = (str: string): boolean =>
  regIsNeg.test(str);

const getAuxiliaryComposedVerb = (str: string): string =>
  (str.match(regGet) || [''])[0];

const getAuxiliaryComposedVerbInNegativeForm = (str: string): string =>
  (str.match(regGetNeg) || [''])[0];

const getInitOfComposedVerb = (str: string): string => str.replace(regGet, '');

const getInitOfComposedVerbInNegativeForm = (str: string): string =>
  str.replace(regGetNeg, '');

const getProperties = (verb: string): VerbProperties => {
  const __originalVerb = verb;
  const firstPart = isAuxiliaryComposedVerb(verb)
    ? getInitOfComposedVerb(verb)
    : isAuxiliaryComposedVerbInNegativeForm(verb)
    ? getInitOfComposedVerbInNegativeForm(verb)
    : hasWhiteSpaces(verb)
    ? getStrLast(verb)
    : '';

  if (isAuxiliaryComposedVerb(verb)) {
    verb = getAuxiliaryComposedVerb(verb);
  } else if (isAuxiliaryComposedVerbInNegativeForm(verb)) {
    verb = getAuxiliaryComposedVerbInNegativeForm(verb);
  } else if (hasWhiteSpaces(verb)) {
    verb = getStrLast(verb);
  }

  return {
    __originalVerb,
    verb,
    firstPart,
    root: mutableVerbs.includes(verb)
      ? verbRoot(verb).replace('t', 'd')
      : verbRoot(verb),

    originalRoot: verbRoot(verb),

    verbSuffix: verb.slice(-3),

    vowelsLength: vowelsQuantity(verb),

    verbVowels: getVowelsStr(verbRoot(verb)),

    harmony4way: get4WayHarmonyOf(verb),

    harmony2way: get2WayHarmonyOf(verb),

    negativeSuffix: 'm' + get2WayHarmonyOf(verb),

    positiveRoot: isNegativeVerb(verb)
      ? getPositiveVerbRootFromNegativeVerb(verb)
      : '',

    isNegative: isNegativeVerb(verb),

    isSingleSyllableVerb: isSingleSyllableVerb(verb),

    // if it has white spaces it means it's composed
    isComposed: hasWhiteSpaces(verb),

    initPart: hasWhiteSpaces(verb) ? getStrInit(verb) : '',

    lastPart: hasWhiteSpaces(verb) ? getStrLast(verb) : '',

    isAuxiliaryComposedVerb: isAuxiliaryComposedVerb(verb),

    auxiliaryVerb: getAuxiliaryComposedVerb(verb),

    initComposedVerb: isAuxiliaryComposedVerb(verb)
      ? getInitOfComposedVerb(verb)
      : '',

    isAuxiliaryComposedVerbInNegativeForm: isAuxiliaryComposedVerbInNegativeForm(
      verb
    ),

    auxiliaryVerbInNegativeForm: getAuxiliaryComposedVerbInNegativeForm(verb),

    initComposedVerbInNegativeForm: isAuxiliaryComposedVerbInNegativeForm(verb)
      ? getInitOfComposedVerbInNegativeForm(verb)
      : '',
  };
};

export {
  verbRoot,
  getPositiveVerbRootFromNegativeVerb,
  arrayOfPersonalSuffixes,
  vowelsQuantity,
  getFirstVowel,
  getLastVowel,
  lookIn4Ways,
  lookIn2Ways,
  get4WayHarmonyOf,
  get2WayHarmonyOf,
  generateResult,
  getProperties,
  hasWhiteSpaces,
};
